import { BookFormData, Chapter } from '@/store/bookStore';

// When developing locally we prefer relative paths so the Vite dev server
// can proxy requests to the backend (see `vite.config.ts`). For production
// a real absolute URL can be supplied via VITE_API_BASE_URL.
const API_BASE_URL = import.meta.env.VITE_API_BASE_URL || '';

// Backend API interfaces
interface BackendChapterPlan {
  title: string;
  summary: string;
  subtopics?: string[];
}

interface BackendBookPlan {
  title: string;
  chapters: BackendChapterPlan[];
}

interface BackendChapterContent {
  title: string;
  content: string;
}

interface BackendBookContent {
  title: string;
  chapters: BackendChapterContent[];
}

export const generateToc = async (formData: BookFormData): Promise<Chapter[]> => {
  try {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), 120000); // 2 minutes timeout

    const response = await fetch(`${API_BASE_URL}/plan`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        topic: formData.topic,
        num_chapters: formData.numberOfChapters,
        tone: formData.tone,
        model: formData.model,
        additional_content: formData.userToc ? 'User provided custom TOC' : undefined,
      }),
      signal: controller.signal,
    });

    clearTimeout(timeoutId);

    if (!response.ok) {
      throw new Error(`API request failed: ${response.status} ${response.statusText}`);
    }

    const data: BackendBookPlan = await response.json();

    // Transform backend data to frontend format
    const chapters: Chapter[] = data.chapters.map((chapter, index) => ({
      id: `ai-chapter-${index + 1}`,
      title: chapter.title,
      subtopics: (chapter.subtopics && chapter.subtopics.length > 0)
        ? chapter.subtopics.map((sub, subIndex) => ({
            id: `ai-chapter-${index + 1}-sub-${subIndex + 1}`,
            title: sub,
          }))
        : [
            { id: `ai-chapter-${index + 1}-sub-1`, title: 'Introduction' },
            { id: `ai-chapter-${index + 1}-sub-2`, title: 'Main Concepts' },
            { id: `ai-chapter-${index + 1}-sub-3`, title: 'Practical Applications' },
            { id: `ai-chapter-${index + 1}-sub-4`, title: 'Summary' },
          ],
      isExpanded: false,
    }));

    return chapters;
  } catch (error) {
    console.error('Error generating TOC:', error);
    throw new Error(`Failed to generate table of contents: ${error instanceof Error ? error.message : 'Unknown error'}`);
  }
};

export const saveUserToc = async (toc: Chapter[]): Promise<void> => {
  // For now, just log - could be extended to save to backend
  console.log('User TOC saved:', toc);
};

export const writeBook = async (
  mergedToc: Chapter[],
  formData: BookFormData
): Promise<Chapter[]> => {
  try {
    // Transform frontend chapters to backend format
    const backendChapters: BackendChapterPlan[] = mergedToc.map(chapter => ({
      title: chapter.title,
      summary: 'Chapter summary to be generated by AI', // Backend will generate proper summaries
    }));

    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), 240000); // 4 minutes timeout for writing

    const response = await fetch(`${API_BASE_URL}/write`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        book_title: `${formData.topic} Guide`, // Could be improved to use actual title
        topic: formData.topic,
        chapters: backendChapters,
        tone: formData.tone,
      }),
      signal: controller.signal,
    });

    clearTimeout(timeoutId);

    if (!response.ok) {
      throw new Error(`API request failed: ${response.status} ${response.statusText}`);
    }

    const data: BackendBookContent = await response.json();

    // Transform backend data to frontend format
    const generatedChapters: Chapter[] = data.chapters.map((chapter, index) => {
      const originalChapter = mergedToc[index];
      return {
        ...originalChapter,
        title: chapter.title,
        content: chapter.content,
        subtopics: originalChapter.subtopics,
      };
    });

    return generatedChapters;
  } catch (error) {
    console.error('Error writing book:', error);
    throw new Error(`Failed to generate book content: ${error instanceof Error ? error.message : 'Unknown error'}`);
  }
};

export const exportBook = async (
  format: 'pdf' | 'epub' | 'markdown',
  chapters: Chapter[]
): Promise<Blob> => {
  try {
    // For now, implement basic markdown export
    // TODO: Integrate with backend export endpoints when available
    const content = chapters.map((ch) => ch.content || `# ${ch.title}\n\nContent not available.`).join('\n\n---\n\n');
    const blob = new Blob([content], { type: 'text/markdown' });

    console.log(`Exporting book as ${format}:`, chapters);
    return blob;
  } catch (error) {
    console.error('Error exporting book:', error);
    throw new Error(`Failed to export book: ${error instanceof Error ? error.message : 'Unknown error'}`);
  }
};
